Basic pass to insert and inline the "nk_fiber_yield" function call every 50 lines of code. *** 

Technical issues:
- [SOLVED]  Injecting function that doesn't exist in current module (i.e. yield)
  Ideas --- link modules correctly (llvm-link, etc.) after bitcode is generated, etc. (CORRECT SOLUTION)
        --- getOrCreateFunction will create a shell, stil could have an empty body (scrapped --- for dummy code)
        --- add necessary files in addition to the -CIY flag upon compilation (scrapped --- Simone's solution?)
        --- write a function that extracts nk_fiber_yield from some Nautilus source file and keeps it in this module (llvm-link solves this issue)

- [SOLVED] Pass is invoked repeatedly since bitcode is modified each time code injections occur
  Ideas --- End pass invocation after certain number of injections are introduced
        --- Complete one pass invocation ONLY, prevent reinvocation of pass by introducing a marker function,
            pass will terminate upon finding the marker function
	--- Just edit the damn script (THIS SOLUTION CHOSEN)

- [SOLVED] Marker function removed
  Marker function deemed unnecessary (Simone), marker function signature can be utilized by other code (conceptually
  speaking), shell for function can fail if there is no body (this pass will not include a body --- expensive)
  Ideas --- remove marker function entirely, prevent reinvocation of pass by changing the makefile (CORRECT SOLUTION)

- [SOLVED] --- Linked modules allows LLVM to find the function with M.getFunction() ; NOTE: Function::Create() with no body is dangerous

- [SOLVED] --- -fgnu89-inline was possibly inlining nk_fiber_yield for this version of nautilus (not sure why), so injecting without calls to nk_fiber_yield or the function body were not present in runOnModule(), fixed by setting attribute in doInitialization to Attribute::NoInline  ;   LLVM::Module::getFunction() fails to recognize nk_fiber_yield in latest commit to Nautilus (mikedev, 7/24/19), with no memory corruption or leaked pointers.

Conceptual issues:
- Injecting yield calls is not smart in all occurrences (e.g. critical sections, presence of locks, etc.), smarter
  to inject in programmer-written routines, IGNORE at context switching/register saving functions in fiber.c, IGNORE
  injecting calls inside deep loops
- [SOLVED] Inlining is necessary post linking ; Inlining via code may not be necessary, pass in flag "analyzer-config ipa=dynamic"
- What should be classified as a tight loop? (Potentially technical issue, likely answered in prior compilers research)

########

inject script: used to install pass, link modules, build nautilus after invoking the pass. CAT-c build (Simone) is necessary in order to build nautilus with the pass.
