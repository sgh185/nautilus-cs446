#include <vector>
#include <set>
#include <map>
#include <queue>
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/ADT/SparseBitVector.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Constants.h"

#include "llvm/Analysis/AliasSetTracker.h"
#include "llvm/Analysis/AliasAnalysis.h"

using namespace llvm;
using namespace std;

/* *********** MAJOR CHANGES FOR H5 ***********
 * Removing Assumptions for CAT API: This solution for H5 takes the conservative approach
 * suggested in H5.pdf:
 * - PART 1) Not considering CAT variables that have been passed to other functions or 
 *           passed to the current function F --- escaping
 * - PART 2) Not considering CAT variables that have been stored in memory or computed using 
 *           pointers to data structures outside the scope of the function
 * 
 * In doing so, all data structures used in this pass now take VALUES instead of INSTRUCTIONS
 * so that it's much simpler to consider arguments to functions (which are values by default)
 * 
 */

#define CAT_ADD 0
#define CAT_SUB 1
#define CAT_NEW 2
#define CAT_GET 3
#define CAT_SET 4
#define printf 5

const vector<uint32_t> CAT_ids = {CAT_ADD, CAT_SUB, CAT_NEW, CAT_GET, CAT_SET, printf};
const vector<string> CAT_names = {"CAT_add", "CAT_sub", "CAT_new", "CAT_get", "CAT_set", "printf"};
map<Function *, uint32_t> CATs;

namespace
{
struct CAT : public FunctionPass
{
    static char ID;
    Module *currM;

    CAT() : FunctionPass(ID) {}

    // This function is invoked once at the initialization phase of the compiler
    // The LLVM IR of functions isn't ready at this point

    bool doInitialization(Module &M) override
    {
        currM = &M;
        // fill CAT func, name, ids consts
        for (auto i = 0; i < CAT_ids.size(); i++)
        {
            auto func = M.getFunction(CAT_names[CAT_ids[i]]);
            if (func != NULL)
                CATs[func] = CAT_ids[i];
        }

        return false;
    }

    // This function is invoked once per function compiled
    // The LLVM IR of the input functions is ready and it can be analyzed and/or transformed
    bool runOnFunction(Function &F) override
    {

        for (auto &B : F)
        {
            for (auto &I : B)
            {
                errs() << "INSTRUCTION: ";
                I.print(errs());
                errs() << "\n";
            }
        }
        //data structures necessary to hold sets, etc --- may make this a struct later
        vector<Value *> Instructions;
        map<Value *, uint32_t> InstructionIDs;
        map<Value *, SparseBitVector<>> GEN;
        map<Value *, SparseBitVector<>> KILL;
        map<Value *, SparseBitVector<>> IN;
        map<Value *, SparseBitVector<>> OUT;
        map<uint32_t, SparseBitVector<>> invocations; // probably doesnt need to be a hashtable
        map<Value *, set<Value *>> defs;              // need to change to bit vectors
        map<Value *, set<Value *>> CFG;               // need to change to bit vectors

        map<Value *, set<Value *>> mays;
        map<Value *, set<Value *>> musts;
        map<Value *, set<Value *>> args;

        errs() << "Function \"" << F.getName() << "\"\n";

        AliasAnalysis &aliasAnalysis = getAnalysis<AAResultsWrapperPass>().getAAResults();

        vector<Instruction *> memInsts;
        vector<Instruction *> pointers;

        uint32_t id = 0;
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                Instructions.push_back(&I);
                InstructionIDs[&I] = id;
                id++;

                // if (I.getType()->isPointerTy() &&
                //     isa<CallInst>(&I))
                // {
                //     pointers.push_back(&I);
                //     continue;
                // }

                if (isa<LoadInst>(&I))
                {
                    if (auto *loadInst = dyn_cast<LoadInst>(&I))
                    {
                        errs() << "---------------\n";
                        errs() << "LOADINST: ";
                        loadInst->print(errs());
                        errs() << "\n";
                        Value *valueLoaded = loadInst->getPointerOperand();
                        errs() << "valueLoaded: ";
                        valueLoaded->print(errs());
                        errs() << "\n";
                        errs() << "---------------\n";
                    }
                    memInsts.push_back(&I);
                    continue;
                }
                if (isa<StoreInst>(&I))
                {
                    if (auto *storeInst = dyn_cast<StoreInst>(&I))
                    {
                        errs() << "---------------\n";
                        errs() << "STOREINST: ";
                        storeInst->print(errs());
                        errs() << "\n";
                        Value *leftSide = storeInst->getValueOperand();
                        errs() << "leftSide: ";
                        leftSide->print(errs());
                        errs() << "\n";
                        Value *rightSide = storeInst->getPointerOperand();
                        errs() << "rightSide: ";
                        rightSide->print(errs());
                        errs() << "\n";
                        errs() << "---------------\n";
                    }
                    memInsts.push_back(&I);
                    continue;
                }
            }
        }

        for (auto &B : F)
        {
            for (auto &I : B)
            {
                if (auto *call = dyn_cast<CallInst>(&I))
                {
                    Function *callee = call->getCalledFunction();

                    if (CATs.count(callee) > 0) // if callee is a CAT function
                    {
                        uint32_t id = CATs[callee];

                        //FILL OUT INVOCATIONS TABLE --- (id represents any of the CAT_FUNCTIONS)
                        invocations[id].set(InstructionIDs[&I]);
                    }
                }
            }
        }

        errs() << "FILLING OUT ARGS TABLE\n";
        for (auto arg = F.arg_begin(); arg != F.arg_end(); ++arg)
        {
            Value *value_arg = cast<Value>(arg);
            errs() << "value_arg: ";
            value_arg->print(errs());
            errs() << "\n";
            args[arg] = set<Value *>();
        }
        errs() << " ### Pointers\n";
        for (auto &pointer : pointers)
        {
            errs() << "\n\n\n\n";
            auto sizePointer = getPointedElementTypeSize(pointer);
            errs() << "   Pointer: \"" << *pointer << "\"\n";
            errs() << "     Size: " << sizePointer << " Bytes\n";

            for (auto &pointer2 : pointers)
            {
                if (pointer == pointer2)
                    continue;

                auto sizePointer2 = getPointedElementTypeSize(pointer2);
                errs() << "     Pointer2: \"" << *pointer2 << "\"\n";
                errs() << "       Size: " << sizePointer2 << " Bytes\n";

                switch (aliasAnalysis.alias(pointer, sizePointer, pointer2, sizePointer2))
                {
                case NoAlias:
                    errs() << "     No alias\n";
                    break;

                case MayAlias:
                    errs() << "     May alias\n";
                    break;

                case PartialAlias:
                    errs() << "     Partial alias\n";
                    break;

                case MustAlias:
                    errs() << "     Must alias\n";
                    break;

                default:
                    errs() << "     In DEFAULT\n";
                }
            }
        }
        errs() << " ### Memory accesses\n";
        for (auto &memInst : memInsts)
        {
            errs() << "\n\n\n\n";
            errs() << "   NEW Mem inst: \"" << *memInst << "\"\n";
            musts[memInst] = set<Value *>();
            mays[memInst] = set<Value *>();

            for (auto &memInst2 : memInsts)
            {
                if (memInst == memInst2)
                    continue;
                errs() << "     Mem inst2: \"" << *memInst2 << "\"\n";

                switch (aliasAnalysis.alias(MemoryLocation::get(memInst), MemoryLocation::get(memInst2)))
                {
                case NoAlias:
                    errs() << "     No alias\n";
                    break;

                case MayAlias:
                {
                    errs() << "     May alias\n";
                    mays[memInst].insert(memInst2);
                }
                break;

                case PartialAlias:
                {
                    musts[memInst].insert(memInst2);
                    errs() << "     Partial alias\n";
                }
                break;

                case MustAlias:
                {
                    musts[memInst].insert(memInst2);
                    errs() << "     Must alias\n";
                }
                break;

                default:
                    errs() << "     In DEFAULT\n";
                }
            }
        }

        errs() << " ### Mod/ref\n";
        for (auto &memInst : memInsts)
        {
            errs() << "\n\n\n\n";
            errs() << "   NEW Mem inst: \"" << *memInst << "\"\n";

            for (auto &pointer : pointers)
            {
                auto sizePointer = getPointedElementTypeSize(pointer);
                errs() << "   Pointer: \"" << *pointer << "\"\n";
                errs() << "     Size: " << sizePointer << " Bytes\n";

                switch (aliasAnalysis.getModRefInfo(memInst, pointer, sizePointer))
                {
                case ModRefInfo::NoModRef:
                    errs() << "     NoModRef\n";
                    break;
                case ModRefInfo::Mod:
                    errs() << "     Mod\n";
                    break;
                case ModRefInfo::Ref:
                    errs() << "     Ref\n";
                    break;
                case ModRefInfo::ModRef:
                    errs() << "     ModRef\n";
                    break;
                default:
                    errs() << "     In DEFAULT\n";
                }
            }
        }

        for (map<Value *, set<Value *>>::iterator it = mays.begin(); it != mays.end(); ++it)
        {
            errs() << "This is the current INST: ";
            it->first->print(errs());
            errs() << "\n";
            set<Value *> temp = it->second;
            errs() << "Here are its MAYS: \n";
            for (set<Value *>::iterator sit = temp.begin(); sit != temp.end(); ++sit)
            {
                (*sit)->print(errs());
                errs() << "\n";
            }
            errs() << "------\n\n\n";
        }

        errs() << "-----------------------------------------------------------------------\n\n\n";
        for (map<Value *, set<Value *>>::iterator it = musts.begin(); it != musts.end(); ++it)
        {
            errs() << "This is the current INST: ";
            it->first->print(errs());
            errs() << "\n";
            set<Value *> temp = it->second;
            errs() << "Here are its MUSTS: \n";
            for (set<Value *>::iterator sit = temp.begin(); sit != temp.end(); ++sit)
            {
                (*sit)->print(errs());
                errs() << "\n";
            }
            errs() << "------\n\n\n";
        }

        //Fill out definitions table --- note that definitions now refers to
        //definitions that originate or alter INSIDE the function F

        //Fill out keys of definition table:
        //Keys will include calls to CAT_NEW, and all arguments of function F
        for (auto cat_new_inst : invocations[CAT_NEW])
        {
            Value *I = Instructions[cat_new_inst];
            defs[I] = set<Value *>();
        }

        for (auto cat_add_inst : invocations[CAT_ADD])
        {

            Instruction *I = cast<Instruction>(Instructions[cat_add_inst]);
            errs() << "CURRENT INSTRUCTION IN CAT_NEW_EXAMINATION: ";
            I->print(errs());
            errs() << "\n";
            auto sizePointer = getPointedElementTypeSize(I);
            for (auto &B : F)
            {
                for (auto &inst : B)
                {
                    errs() << "CURRENT memInst : ";
                    inst.print(errs());
                    errs() << "\n";
                    switch (aliasAnalysis.getModRefInfo(&inst, I, sizePointer))
                    {
                    case ModRefInfo::NoModRef:
                        errs() << "     NoModRef\n";
                        break;
                    case ModRefInfo::Mod:
                        errs() << "     Mod\n";
                        break;
                    case ModRefInfo::Ref:
                        errs() << "     Ref\n";
                        break;
                    case ModRefInfo::ModRef:
                        errs() << "     ModRef\n";
                        break;
                    default:
                        errs() << "     In DEFAULT\n";
                    }
                }
                // for (auto &inst : B)
                // {
                //     errs() << "CURRENT memInst : ";
                //     inst.print(errs());
                //     errs() << "\n";
                //     switch (aliasAnalysis.alias(MemoryLocation::get(I), MemoryLocation::get(&inst)))
                //     {
                //     case NoAlias:
                //         errs() << "     No alias\n";
                //         break;

                //     case MayAlias:
                //     {
                //         errs() << "     May alias\n";
                //     }
                //     break;

                //     case PartialAlias:
                //         errs() << "     Partial alias\n";
                //         break;

                //     case MustAlias:
                //     {
                //         errs() << "     Must alias\n";
                //     }
                //     break;

                //     default:
                //         errs() << "     In DEFAULT\n";
                //     }
                // }
            }
        }

        for (map<Value *, set<Value *>>::iterator it = args.begin(); it != args.end(); ++it)
        {
            Value *arg = it->first;
            defs[arg] = set<Value *>();
            errs() << "This is the current arg: ";
            it->first->print(errs());
            errs() << "\n";
            errs() << "------\n\n\n";
        }

        for (auto &B : F)
        {
            for (auto &I : B)
            {
                if (isa<PHINode>(I))
                    continue;
                else if (auto *call = dyn_cast<CallInst>(&I))
                {
                    Function *callee = call->getCalledFunction();

                    if (CATs.count(callee) > 0) // if callee is a CAT function
                    {
                        uint32_t id = CATs[callee];

                        //FILL OUT INVOCATIONS TABLE --- (id represents any of the CAT_FUNCTIONS)
                        // invocations[id].set(InstructionIDs[&I]);

                        //FILL OUT DEFINITIONS TABLE
                        switch (id)
                        {
                        case CAT_NEW: // as far as the tests and the H5.PDF goes, CAT_NEW must accept a numeric value
                        {
                            defs[&I] = set<Value *>();
                            defs[&I].insert(&I);
                        }
                        break;
                        case CAT_ADD:
                        case CAT_SUB:
                        case CAT_SET:
                        {
                            auto definition = call->getArgOperand(0);

                            /* RELAXING ASSUMPTIONS */
                            // If the current instruction is an argument of F and there
                            // are no definitions for the var (first operand) passed to
                            // add, sub, or set, create a new entry in the defs table
                            if (args.count(definition) > 0)
                            {
                                if (defs.count(definition) == 0)
                                    defs[definition] = set<Value *>();
                            }

                            defs[definition].insert(&I);
                        }
                        break;
                        case printf:
                            break;
                        }
                    }
                }
                else if (auto *storeInst = dyn_cast<StoreInst>(&I))
                {
                    errs() << "---------------\n";
                    errs() << "STOREINST: ";
                    storeInst->print(errs());
                    errs() << "\n";
                    Value *valueStored = storeInst->getPointerOperand();
                    errs() << "valueStored: ";
                    valueStored->print(errs());
                    errs() << "\n";
                    errs() << "---------------\n";

                    if (defs.count(valueStored) == 0)
                    {
                        defs[valueStored] = set<Value *>();
                        defs[valueStored].insert(valueStored);
                    }

                    set<Value *> temp = musts[storeInst];
                    for (auto must : temp)
                        defs[valueStored].insert(must);
                }
            }
        }
        errs() << "-----------------------------------------------------------------------\n\n\n";
        errs() << "FINAL DEFS TABLE\n";
        for (map<Value *, set<Value *>>::iterator it = defs.begin(); it != defs.end(); ++it)
        {
            errs() << "This is the current value: ";
            it->first->print(errs());
            for (auto &U : it->first->uses()) {
                errs() << "USERS: ";
                U->print(errs());
                errs() << "\n";
            }
            errs() << "\n";
            set<Value *> temp = it->second;
            errs() << "Here are its definitions: \n";
            for (set<Value *>::iterator sit = temp.begin(); sit != temp.end(); ++sit)
            {
                (*sit)->print(errs());
                errs() << "\n";
            }
            errs() << "------\n\n\n";
        }

        // COMPUTE GEN, KILL SETS
        // NOTE: There are no changes here as gen and kill sets for instructions
        // that use CAT vars based on prior assumptions, if they're passed
        // as args, or stored/referenced from memory --- doesn't matter. they still
        // need to be recorded to calculate in and out correctly.
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                GEN[&I] = SparseBitVector<>();
                KILL[&I] = SparseBitVector<>();

                if (auto *call = dyn_cast<CallInst>(&I)) // if the instruction contains a call
                {
                    Function *callee = call->getCalledFunction(); // get function that was called in the instruction

                    if (CATs.count(callee) > 0)
                    {
                        auto id = CATs[callee];
                        switch (id)
                        {
                        case CAT_NEW: // ignore because takes a numeric value
                        {
                            if (defs.count(&I) > 0)
                            {
                                GEN[&I].set(InstructionIDs[&I]); //gen set will contain first def
                                for (set<Value *>::iterator E = defs[&I].begin(); E != (defs[&I].end()); E++)
                                {
                                    if (InstructionIDs[*E] != InstructionIDs[&I])
                                        KILL[&I].set(InstructionIDs[*E]);
                                }
                            }
                        }
                        break;
                        case CAT_ADD:
                        case CAT_SUB:
                        case CAT_SET:
                        {
                            auto zero_operand = call->getArgOperand(0);
                            if (defs.count(zero_operand) > 0)
                            {
                                GEN[&I].set(InstructionIDs[&I]);
                                for (set<Value *>::iterator E = defs[zero_operand].begin(); E != (defs[zero_operand].end()); E++)
                                {
                                    if (InstructionIDs[*E] != InstructionIDs[&I])
                                        KILL[&I].set(InstructionIDs[*E]);
                                }
                            }
                        }
                        break;
                        }
                    }
                }
                else if (auto *loadInst = dyn_cast<LoadInst>(&I))
                {
                    errs() << "---------------\n";
                    errs() << "LOADINST: ";
                    loadInst->print(errs());
                    errs() << "\n";
                    Value *valueLoaded = loadInst->getPointerOperand();
                    errs() << "valueLoaded: ";
                    valueLoaded->print(errs());
                    errs() << "\n";
                    errs() << "---------------\n";
                    if (defs.count(valueLoaded) > 0)
                    {
                        GEN[&I].set(InstructionIDs[&I]);
                        for (set<Value *>::iterator E = defs[valueLoaded].begin(); E != (defs[valueLoaded].end()); E++)
                        {
                            if (InstructionIDs[*E] != InstructionIDs[&I])
                                KILL[&I].set(InstructionIDs[*E]);
                        }
                    }
                }
            }
        }

        //----------------------------------------
        //----------------------------------------
        //constructing pseudo CFG --- only accounting for terminator of pred BB to front inst of successor BB
        //The idea here is that the in set of an instruction will be computed from the pred instruction ONLY
        //if it's not the first instruction of a basic block. If it's the first instruction of a basic block
        //then the in set is the union of ALL predecessors (of which there can be many) --- so the pseudo CFG
        //stores all the terminators of the pred basic blocks --- mapped to the instruction of the successor BB's
        //first instruction
        for (auto &B : F)
        {
            Value *first = &(B.front());
            CFG[first] = set<Value *>();
            for (auto predBB : predecessors(&B))
            {
                Value *terminator = predBB->getTerminator();
                CFG[first].insert(terminator);
            }
        }

        //------IN AND OUT SETS ----------

        //init in and out sets
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                IN[&I] = SparseBitVector<>();
                OUT[&I] = SparseBitVector<>();
            }
        }

        // NO CHANGES FOR H5
        //This is the algorithm shown in class (non-worklist)
        //The OUT sets will be recomputed until there are NO CHANGES to any OUT sets. This process
        //is very simple as the sparse bit vectors
        //allow for the out sets to be computed using simple - and || operations
        //(The implementation of the bitwise instructions were found on pg 394 of the textbook)
        bool changed = true;
        while (changed)
        {
            changed = false; // we want to change to true when analyzing out sets
            for (auto &B : F)
            {
                Value *pred_inst = NULL;

                //save temp for comparison purposes
                map<Value *, SparseBitVector<>> temp = OUT;

                for (auto &I : B)
                {
                    //IN SETS
                    if (CFG.count(&I) > 0) // the instruction IS FIRST instruction of BB
                    {
                        for (auto &terminator : CFG[&I])
                            IN[&I] = IN[&I] | OUT[terminator]; // union
                    }

                    else if (CFG.count(&I) == 0) // the instruction is NOT first instruction of BB
                        IN[&I] = IN[&I] | OUT[pred_inst];

                    //OUT SETS
                    OUT[&I] = OUT[&I] | (GEN[&I] | (IN[&I] - KILL[&I]));

                    pred_inst = &I; // while loop --- so the instruction needs to be incremnted
                }

                if (temp != OUT) // if there was a change
                    changed = true;
            }
        }

        for (auto &B : F)
        {
            for (auto &I : B)
            {
                errs() << "INSTRUCTION: ";
                I.print(errs());
                errs() << "\n";
                errs() << "***************** "
                       << "GEN"
                       << "\n{"
                       << "\n";
                for (auto gen : GEN[&I])
                {
                    errs() << " " << *(Instructions[gen]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "KILL"
                       << "\n{"
                       << "\n";
                for (auto kill : KILL[&I])
                {
                    errs() << " " << *(Instructions[kill]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "IN"
                       << "\n{"
                       << "\n";
                for (auto in : IN[&I])
                {
                    errs() << " " << *(Instructions[in]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "OUT"
                       << "\n{"
                       << "\n";
                for (auto out : OUT[&I])
                {
                    errs() << " " << *(Instructions[out]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "\n\n\n";
            }
        }
        /* **** PREPROCESSING **** 
        Several steps --- broken into separate for loops for 
        code readability */

        //Fill out instructions vector, fill out ids table
        return false;
    }

    uint64_t
    getPointedElementTypeSize(Instruction *pointer)
    {
        uint64_t size = 0;

        if (auto pointerType = dyn_cast<PointerType>(pointer->getType()))
        {
            auto elementPointedType = pointerType->getElementType();
            if (elementPointedType->isSized())
            {
                size = currM->getDataLayout().getTypeStoreSize(elementPointedType);
            }
        }

        return size;
    }

    // We don't modify the program, so we preserve all analyses.
    // The LLVM IR of functions isn't ready at this point
    void getAnalysisUsage(AnalysisUsage &AU) const override
    {
        AU.addRequired<AAResultsWrapperPass>();
        AU.setPreservesAll();
    }
}; // namespace
} // namespace
// Next there is code to register your pass to "opt"
char CAT::ID = 0;
static RegisterPass<CAT> X("CAT", "Homework for the CAT class");

// Next there is code to register your pass to "clang"
static CAT *_PassMaker = NULL;
static RegisterStandardPasses _RegPass1(PassManagerBuilder::EP_OptimizerLast,
                                        [](const PassManagerBuilder &, legacy::PassManagerBase &PM) {
        if(!_PassMaker){ PM.add(_PassMaker = new CAT());} }); // ** for -Ox
static RegisterStandardPasses _RegPass2(PassManagerBuilder::EP_EnabledOnOptLevel0,
                                        [](const PassManagerBuilder &, legacy::PassManagerBase &PM) {
        if(!_PassMaker){ PM.add(_PassMaker = new CAT()); } }); // ** for -O0

