#include <vector>
#include <set>
#include <map>
#include <queue>
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/ADT/SparseBitVector.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Constants.h"

using namespace llvm;
using namespace std;

/* *********** IMPLEMENTATION OF COPY PROPAGATION ***********
 * The idea is to implement copy propagation for the CAT api that does not
 * just resort to optimizing something like d1 = d2 (which O1 optimizes). Instead,
 * this copy propagation recognizes something similar to 
 * 
 * CAT_set(d2, CAT_get(d1));
 * 
 * OR
 * 
 * CATData d2 = CAT_new(CAT_get(d1)); 
 * 
 * as a redefinition. In the first example d2 is a high level copy of d1, and in the 
 * second example, d2 is defined with the same value as d1.
 * 
 * Using this information, d2 in both cases are replaced with d1's value as much as possible
 * in future instructions before the value of d1 and d2 differ. As a result, many of d2's uses
 * are replaced to the point where d2 can be removed using extensive dead code elimination 
 * (granted that there are no more CAT_gets left that call d2)
 * 
 * NOTE: A more aggressive form of copy propagation is applied where CAT_new, CAT_set declarations
 * that have the same value when defined are treated as the same CAT variable until the CAT 
 * variables start to differ in value
 */

#define CAT_ADD 0
#define CAT_SUB 1
#define CAT_NEW 2
#define CAT_GET 3
#define CAT_SET 4
#define printf 5

const vector<uint32_t> CAT_ids = {CAT_ADD, CAT_SUB, CAT_NEW, CAT_GET, CAT_SET, printf};
const vector<string> CAT_names = {"CAT_add", "CAT_sub", "CAT_new", "CAT_get", "CAT_set", "printf"};
map<Function *, uint32_t> CATs;

namespace
{

struct foldInfo
{
    bool foldable;
    Value *result;
};
struct CAT : public FunctionPass
{
    static char ID;

    CAT() : FunctionPass(ID) {}

    // This function is invoked once at the initialization phase of the compiler
    // The LLVM IR of functions isn't ready at this point
    bool doInitialization(Module &M) override
    {
        // fill CAT func, name, ids consts
        for (auto i = 0; i < CAT_ids.size(); i++)
        {
            auto func = M.getFunction(CAT_names[CAT_ids[i]]);
            if (func != NULL)
                CATs[func] = CAT_ids[i];
        }

        return false;
    }

    // This function is invoked once per function compiled
    // The LLVM IR of the input functions is ready and it can be analyzed and/or transformed
    bool runOnFunction(Function &F) override
    {
        //data structures necessary to hold sets, etc --- may make this a struct later
        vector<Value *> Instructions;
        map<Value *, uint32_t> InstructionIDs;
        map<Value *, SparseBitVector<>> GEN;
        map<Value *, SparseBitVector<>> KILL;
        map<Value *, SparseBitVector<>> IN;
        map<Value *, SparseBitVector<>> OUT;
        map<uint32_t, SparseBitVector<>> invocations; // probably doesnt need to be a hashtable
        vector<Value *> totalInvocations;             // ALL CAT instructions (not including print)

        map<Value *, set<Value *>> defs; // need to change to bit vectors
        map<Value *, set<Value *>> CFG;  // need to change to bit vectors

        map<Value *, set<Value *>> args;
        map<Value *, set<Value *>> related_NEW;

        /* **** PREPROCESSING **** 
        Several steps --- broken into separate for loops for 
        code readability */

        //Fill out instructions vector, fill out ids table
        uint32_t id = 0;
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                Instructions.push_back(&I);
                InstructionIDs[&I] = id;
                id++;

                if (auto *call = dyn_cast<CallInst>(&I))
                {
                    Function *callee = call->getCalledFunction();

                    if (CATs.count(callee) > 0)
                    {
                        uint32_t id = CATs[callee];
                        invocations[id].set(InstructionIDs[&I]);

                        if (CATs[callee] != printf)
                        {
                            I.print(errs());
                            errs() << "\n";
                            totalInvocations.push_back(&I);
                        }
                    }
                }
            }
        }

        //Record arguments of function F
        for (auto arg = F.arg_begin(); arg != F.arg_end(); ++arg)
        {
            Value *value_arg = cast<Value>(arg);
            args[arg] = set<Value *>();
        }

        // DEFINITIONS TABLE
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                if (auto *call = dyn_cast<CallInst>(&I))
                {
                    Function *callee = call->getCalledFunction();

                    if (CATs.count(callee) > 0) // if callee is a CAT function
                    {
                        uint32_t id = CATs[callee];

                        //FILL OUT DEFINITIONS TABLE
                        switch (id)
                        {
                        case CAT_NEW:
                        {
                            if (defs.count(&I) == 0)
                                defs[&I] = set<Value *>();

                            defs[&I].insert(&I);
                        }
                        break;
                        case CAT_ADD:
                        case CAT_SUB:
                        case CAT_SET:
                        {
                            auto definition = call->getArgOperand(0);

                            /* RELAXING ASSUMPTIONS */
                            // If the current instruction is an argument of F and there
                            // are no definitions for the var (first operand) passed to
                            // add, sub, or set, create a new entry in the defs table
                            if (args.count(definition) > 0)
                            {
                                if (defs.count(definition) == 0)
                                    defs[definition] = set<Value *>();
                            }

                            if (defs.count(definition) == 0)
                            {
                                defs[&I] = set<Value *>();
                                defs[&I].insert(&I);
                            }
                            else
                                defs[definition].insert(&I);
                        }
                        break;
                        case printf:
                            break;
                        }
                    }
                }
                else if (auto *phi = dyn_cast<PHINode>(&I))
                {
                    if (args.count(phi) > 0)
                    {
                        if (defs.count(phi) == 0)
                            defs[phi] = set<Value *>();
                    }

                    if (defs.count(phi) == 0)
                    {
                        defs[&I] = set<Value *>();
                        defs[&I].insert(&I);
                    }
                    else
                        defs[phi].insert(&I);

                    for (uint32_t opNO = 0; opNO < phi->getNumOperands(); opNO++)
                    {
                        Value *opI = cast<Value>(phi->getOperand(opNO));

                        if (defs.count(opI) > 0)
                            defs[opI].insert(phi);
                        else
                        {
                            if (auto *op_call = dyn_cast<CallInst>(opI))
                            {
                                Function *op_callee = op_call->getCalledFunction();
                                if (CATs.count(op_callee) > 0)
                                {
                                    if (CATs[op_callee] == CAT_NEW)
                                    {
                                        if (defs.count(opI) == 0)
                                        {
                                            defs[opI] = set<Value *>();
                                            defs[opI].insert(opI);
                                            defs[opI].insert(phi);
                                        }
                                    }
                                }
                            }
                            else if (args.count(opI) > 0)
                            {
                                if (defs.count(opI) == 0)
                                {
                                    defs[opI] = set<Value *>();
                                    defs[opI].insert(opI);
                                    defs[opI].insert(phi);
                                }
                            }
                        }
                    }
                }
            }
        }

        /* NEW FOR H5:
         * Iterate over ALL definitions --- 
         * 
         * The purpose is to identify new CAT variables that are passed to functions
         * inside F from the uses of each definition --- those are escaped and will be
         * ignored.
         * 
         * Also, if a variable is stored and referenced later, these will not be 
         * considered either (per H5.pdf)
         * 
         */
        for (map<Value *, set<Value *>>::iterator it = defs.begin(); it != defs.end(); ++it)
        {
            Value *curr = it->first;

            // Filtering for args of other functions (funcs called/invoked for example)
            // Args already in the args table should be ignored
            if (args.count(curr) > 0)
                continue;

            for (auto &U : curr->uses())
            {
                User *user = U.getUser();

                // If the variable defined is used by a function other than the
                // CAT APIs or printf (printf is part of the CATs set), then
                // add to args table --- this is an escaped variable
                if (auto *user_as_call_inst = dyn_cast<CallInst>(user))
                {
                    Function *callee = user_as_call_inst->getCalledFunction();
                    if (CATs.count(callee) == 0)
                        args[curr] = set<Value *>();
                }

                // If CAT variable is stored in memory (could be used as a reference in a
                // function call, dereferenced later, etc.) --- mark in the args table,
                // these will not be considered in the transformation
                else if (auto *storeInst = dyn_cast<StoreInst>(user))
                {
                    Value *valueStored = storeInst->getValueOperand();
                    if (auto *valueStored_call = dyn_cast<CallInst>(valueStored))
                    {
                        Function *callee = valueStored_call->getCalledFunction();
                        if (CATs.count(callee) > 0)
                        {
                            if (CATs[callee] == CAT_NEW)
                                args[curr] = set<Value *>();
                        }
                    }
                }
            }
        }

        // COMPUTE GEN, KILL SETS
        // NOTE: There are no changes here as gen and kill sets for instructions
        // that use CAT vars based on prior assumptions, if they're passed
        // as args, or stored/referenced from memory --- doesn't matter. they still
        // need to be recorded to calculate in and out correctly.
        for (auto &B : F)
        {
            for (auto &I : B)
            {
                GEN[&I] = SparseBitVector<>();
                KILL[&I] = SparseBitVector<>();

                if (auto *call = dyn_cast<CallInst>(&I)) // if the instruction contains a call
                {
                    Function *callee = call->getCalledFunction(); // get function that was called in the instruction

                    if (CATs.count(callee) > 0)
                    {
                        auto id = CATs[callee];
                        switch (id)
                        {
                        case CAT_NEW: // ignore because takes a numeric value
                        {
                            if (defs.count(&I) > 0)
                            {
                                GEN[&I].set(InstructionIDs[&I]); //gen set will contain first def
                                for (set<Value *>::iterator E = defs[&I].begin(); E != (defs[&I].end()); E++)
                                {
                                    if (InstructionIDs[*E] != InstructionIDs[&I])
                                        KILL[&I].set(InstructionIDs[*E]);
                                }
                            }
                        }
                        break;
                        case CAT_ADD:
                        case CAT_SUB:
                        case CAT_SET:
                        {
                            Value *definition = NULL;

                            for (map<Value *, set<Value *>>::iterator it = defs.begin(); it != defs.end(); ++it)
                            {
                                definition = it->first;
                                set<Value *> temp = defs[definition];
                                set<Value *>::iterator sit = temp.begin();
                                sit = temp.find(&I);

                                if (sit != temp.end())
                                    break;
                                else
                                    definition = NULL;
                            }

                            if (definition == NULL)
                                continue;

                            GEN[&I].set(InstructionIDs[&I]);
                            for (set<Value *>::iterator E = defs[definition].begin(); E != (defs[definition].end()); E++)
                            {
                                if ((InstructionIDs[*E] != InstructionIDs[&I]))
                                    KILL[&I].set(InstructionIDs[*E]);
                            }
                        }
                        break;
                        }
                    }
                }
                else if (auto *phi = dyn_cast<PHINode>(&I))
                {
                    GEN[&I].set(InstructionIDs[&I]);
                    for (set<Value *>::iterator E = defs[&I].begin(); E != (defs[&I].end()); E++)
                    {
                        if (InstructionIDs[*E] != InstructionIDs[&I])
                            KILL[&I].set(InstructionIDs[*E]);
                    }
                }
            }
        }

        //----------------------------------------
        //----------------------------------------
        //constructing pseudo CFG --- only accounting for terminator of pred BB to front inst of successor BB
        //The idea here is that the in set of an instruction will be computed from the pred instruction ONLY
        //if it's not the first instruction of a basic block. If it's the first instruction of a basic block
        //then the in set is the union of ALL predecessors (of which there can be many) --- so the pseudo CFG
        //stores all the terminators of the pred basic blocks --- mapped to the instruction of the successor BB's
        //first instruction
        queue<BasicBlock *> workListIO;

        for (auto &B : F)
        {
            workListIO.push(&B);
            Value *first = &(B.front());

            CFG[first] = set<Value *>();
            IN[first] = SparseBitVector<>();
            OUT[first] = SparseBitVector<>();

            for (auto predBB : predecessors(&B))
            {
                Value *terminator = predBB->getTerminator();
                CFG[first].insert(terminator);
            }

            for (auto &I : B)
            {
                IN[&I] = SparseBitVector<>();
                OUT[&I] = SparseBitVector<>();
            }
        }

        while (!workListIO.empty())
        {
            BasicBlock *B = workListIO.front();
            workListIO.pop();

            // Work with the first instruction of BB
            auto first = &*B->begin();

            if (CFG.count(first) > 0)
            {
                for (auto &pred : CFG[first])
                    IN[first] |= OUT[pred];
            }

            if (OUT[first] |= ((IN[first] - KILL[first]) | GEN[first]))
            {
                for (auto s : successors(B))
                    workListIO.push(s);
            }

            auto propagatingOut = OUT[first];

            for (auto iter = (++B->begin()); iter != B->end(); ++iter)
            {
                auto I = &*iter;

                IN[I] |= propagatingOut;
                OUT[I] |= ((IN[I] - KILL[I]) | GEN[I]);
                propagatingOut = OUT[I];
            }

            OUT[&*B->getTerminator()] = propagatingOut;
        }

        /* CONSTANT PROPAGATION --- (Please see explanation at the top)
         *
         * 
         */

        errs() << "Passednew\n";

        for (auto cat_new_inst : invocations[CAT_NEW])
        {
            CallInst *I = cast<CallInst>(Instructions[cat_new_inst]);
            auto op_0 = I->getArgOperand(0);

            bool added = false;

            for (auto in : IN[I])
            {
                Value *in_I = Instructions[in];
                if (auto *call = dyn_cast<CallInst>(in_I))
                {
                    Function *callee = call->getCalledFunction();

                    if (CATs.count(callee) > 0)
                    {
                        if (CATs[callee] == CAT_NEW)
                        {
                            auto in_0 = call->getArgOperand(0);
                            if (isa<ConstantInt>(in_0))
                            {
                                if (in_0 == op_0)
                                {
                                    if (related_NEW.count(in_I) > 0)
                                    {
                                        related_NEW[in_I].insert(I);
                                        added = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!added)
            {
                related_NEW[I] = set<Value *>();
                related_NEW[I].insert(I);
            }
        }
        errs() << "Passedtotal\n";

        for (auto I : totalInvocations)
        {
            errs() << "\n\n\n\nCurrent INVOC:\n";
            I->print(errs());
            errs() << "inside\n";

            if (auto *call = dyn_cast<CallInst>(I))
            {
                Function *callee = call->getCalledFunction();

                auto id = CATs[callee];
                switch (id)
                {
                case CAT_GET:
                {
                    errs() << "get\n";
                    auto *op_get = call->getArgOperand(0);
                    op_get->print(errs());
                    errs() << "\n";
                    copyPropSetOperand(op_get, I, 0, related_NEW, Instructions, InstructionIDs, IN, CATs);
                }
                break;
                case CAT_ADD:
                case CAT_SUB:
                {
                    errs() << "op1\n";
                    auto *op_1 = call->getArgOperand(1);
                    op_1->print(errs());
                    errs() << "\n";
                    errs() << "op2\n";
                    auto *op_2 = call->getArgOperand(2);
                    op_2->print(errs());
                    errs() << "\n";

                    copyPropSetOperand(op_1, I, 1, related_NEW, Instructions, InstructionIDs, IN, CATs);
                    copyPropSetOperand(op_2, I, 2, related_NEW, Instructions, InstructionIDs, IN, CATs);
                }
                break;
                }
            }

            // Value *I = Instructions[cat_get_inst];
            // errs() << "\n\n\nCurrent get:\n";
            // I->print(errs());
            // errs() << "\n";
            // Value *op = NULL;
            // if (auto *call = dyn_cast<CallInst>(I))
            // {
            //     call->getArgOperand(0)->print(errs());
            //     errs() << "\n";
            //     if (auto *in_call = dyn_cast<CallInst>(call->getArgOperand(0)))
            //     {
            //         Function *callee = in_call->getCalledFunction();

            //         in_call->print(errs());
            //         errs() << "\n";
            //         if (CATs.count(callee) > 0)
            //         {
            //             if (CATs[callee] == CAT_NEW)
            //             {
            //                 errs() << "In here\n";
            //                 op = call->getArgOperand(0);
            //             }
            //         }
            //     }
            // }

            // copyPropSetOperand(op, I, 0, related_NEW, Instructions, InstructionIDs, IN, CATs);
        }
        errs() << "Passedafter\n";

        // queue<uint32_t> workListC;
        // for (auto cat_add_inst : invocations[CAT_ADD])
        //     workListC.push(cat_add_inst);
        // for (auto cat_sub_inst : invocations[CAT_SUB])
        //     workListC.push(cat_sub_inst);

        // while (!workListC.empty())
        // {
        //     Value *I = Instructions[workListC.front()];
        //     workListC.pop();

        //     if (auto *call = dyn_cast<CallInst>(I))
        //     {
        //         Function *callee = call->getCalledFunction();

        //         if (CATs.count(callee) > 0)
        //         {
        //             auto id = CATs[callee];

        //             // these declarations and casts can be simplified later ----
        //             // get the 1st, 2nd, and 3rd operands of the add/sub insts
        //             auto op_1 = call->getArgOperand(1);
        //             auto op_2 = call->getArgOperand(2);

        //             copyPropSetOperand(op_1, I, 1, related_NEW, Instructions, InstructionIDs, IN, CATs);
        //             copyPropSetOperand(op_2, I, 2, related_NEW, Instructions, InstructionIDs, IN, CATs);
        //         }
        //     }
        // }

        for (map<Value *, set<Value *>>::iterator it = related_NEW.begin(); it != related_NEW.end(); ++it)
        {
            Value *curr = it->first;
            errs() << "CURRENT KEY: ";
            curr->print(errs());
            errs() << "\n";

            // for (auto &U : curr->uses())
            // {
            //     errs() << "USER: \n";
            //     User *user = U.getUser();
            //     user->print(errs());
            //     errs() << "\n";
            // }

            errs() << "\n";
            set<Value *> temp = it->second;
            errs() << "Here are its related: \n";
            for (set<Value *>::iterator sit = temp.begin(); sit != temp.end(); ++sit)
            {
                (*sit)->print(errs());
                errs() << "\n";
            }
            errs() << "------\n\n\n";
        }

        /* CONSTANT FOLDING ----
         * 
         * Record all possible folds from CAT_ADD, CAT_SUB. Mark each add/sub instruction as foldable
         * or not. add/sub inst is foldable IFF there is only one reaching definition for each of the 
         * 2nd and 3rd operands of add/sub. (More powerful optimization is checking if there is only one
         * unique reaching value --- this was done for cat_get, will add to fold in the future). 
         * 
         * Bool foldable and the fold result are stored in a struct FoldInfo for each inst. All foldInfo
         * is stored in a map "folds" (keys are inst ids). 
         * 
         * NOTE: The folds map is used by the constant propagation loop later. Since constant folding using
         * the CAT api isn't possible by replacing the entire ADD/SUB with a literal, the actual replacement
         * with the folds occurs in the CONSTANT PROP loop (explained later). 
         * 
         * The above variation was chosen over replacing cat_add/sub with cat_sets because invoking the 
         * IRBuilder is most likely expensive, replacing with cat_sets isn't always possible as some programs
         * don't contain cat_set to begin with (for the IRBuilder to invoke).
         * 
         * 
         * FOR H5 --- There are minor changes --- since store/referenced vars AND vars escaping through arguments
         * to other functions are all kept in the args table --- we only need to check against the table
         * on certain conditions to make sure that foldable instructions are being marked correctly.
         */
        queue<uint32_t> workListF;
        for (auto cat_add_inst : invocations[CAT_ADD])
            workListF.push(cat_add_inst);
        for (auto cat_sub_inst : invocations[CAT_SUB])
            workListF.push(cat_sub_inst);

        map<uint32_t, foldInfo> folds;

        while (!workListF.empty())
        {
            Value *I = Instructions[workListF.front()];
            workListF.pop();
            bool willFold = true;

            if (auto *call = dyn_cast<CallInst>(I))
            {
                Function *callee = call->getCalledFunction();

                if (CATs.count(callee) > 0)
                {
                    auto id = CATs[callee];

                    // these declarations and casts can be simplified later ----
                    // get the 1st, 2nd, and 3rd operands of the add/sub insts
                    auto op_0 = call->getArgOperand(0);
                    auto op_1 = call->getArgOperand(1);
                    auto op_2 = call->getArgOperand(2);

                    Value *opI_0 = cast<Value>(op_0); // for comparison purposes later
                    Value *opI_1 = cast<Value>(op_1);
                    Value *opI_2 = cast<Value>(op_2);

                    // **** CHECK THE ARGS TABLE ****
                    // Here, if the either of the 2nd or 3rd operands to a
                    // cat_add/sub function are escaped vars --- then record
                    // as non-foldable. The result stored does not matter
                    // in this case
                    if ((args.count(opI_1) > 0) || (args.count(opI_2) > 0))
                    {
                        foldInfo temp;
                        Value *v = opI_0;      // dummy value --- can be anything
                        temp.foldable = false; // this is the more important value for this condition
                        temp.result = v;       // dummy value --- doesn't matter what the setting is, as long as I is not foldable
                        folds[InstructionIDs[I]] = temp;
                        continue;
                    }

                    bool op_1_foldable = true;
                    bool op_2_foldable = true;

                    uint32_t count_1 = 0; // number of reaching defs for the 2nd operand (2nd arg)
                    uint32_t count_2 = 0; // number of reaching defs for the 3nd operand (3nd arg)

                    Value *reach_inst_1 = NULL;
                    Value *reach_inst_2 = NULL;

                    // Loop through the in set of the current add/sub instruction (I) to see and examine
                    // instructions related to the 2nd and 3rd operands of I
                    for (auto in : IN[I])
                    {
                        if (auto *in_call = dyn_cast<CallInst>(Instructions[in]))
                        {
                            Function *callee = in_call->getCalledFunction();

                            if (CATs.count(callee) > 0)
                            {
                                auto id = CATs[callee];
                                switch (id)
                                {
                                case CAT_NEW:
                                {
                                    if (in == InstructionIDs[opI_1])
                                    {
                                        count_1++;
                                        reach_inst_1 = opI_1;
                                    }
                                    if (in == InstructionIDs[opI_2])
                                    {
                                        count_2++;
                                        reach_inst_2 = opI_2;
                                    }
                                }
                                break;
                                case CAT_SET:
                                case CAT_ADD:
                                case CAT_SUB:
                                {
                                    Value *op = cast<Value>(in_call->getArgOperand(0));
                                    bool I_foldable = true;

                                    if (folds.find(in) != folds.end()) // filters for add_sub
                                        I_foldable = folds[in].foldable;

                                    if (InstructionIDs[op] == InstructionIDs[opI_1])
                                    {
                                        count_1++;
                                        op_1_foldable = I_foldable;
                                        reach_inst_1 = Instructions[in];
                                    }
                                    if (InstructionIDs[op] == InstructionIDs[opI_2])
                                    {
                                        count_2++;
                                        op_2_foldable = I_foldable;
                                        reach_inst_2 = Instructions[in];
                                    }
                                }
                                }
                            }
                        }
                    }

                    // willFold is set to false if there's more than one reaching definition for either
                    // operand, or if 2nd and 3rd operands can't be folded based on the in set of I
                    if (count_1 != 1 || count_2 != 1)
                        willFold = false;

                    if (!op_1_foldable || !op_2_foldable)
                        willFold = false;

                    // Conservative analysis during constant folding --- only looking at
                    // number of reaching definitions --- this should be improved later
                    // Constant PROPAGATION examins phiNodes carefully to avoid assumption 2.2
                    Value *numeric_1 = getNumericalValue(reach_inst_1, InstructionIDs, folds, CATs);
                    Value *numeric_2 = getNumericalValue(reach_inst_2, InstructionIDs, folds, CATs);

                    if ((isa<PHINode>(opI_1) || isa<PHINode>(opI_2)) || (numeric_1 == NULL || numeric_2 == NULL))
                    {
                        foldInfo temp;
                        Value *v = opI_1; // dummy value --- can be anything
                        temp.foldable = false;
                        temp.result = v;
                        folds[InstructionIDs[I]] = temp;
                        continue;
                    }

                    if (isa<ConstantInt>(numeric_1) && isa<ConstantInt>(numeric_2))
                    {
                        ConstantInt *first = cast<ConstantInt>(numeric_1);
                        int64_t cons_1 = first->getSExtValue();
                        ConstantInt *second = cast<ConstantInt>(numeric_2);
                        int64_t cons_2 = second->getSExtValue();

                        if (id == CAT_ADD)
                            cons_2 += cons_1;
                        else if (id == CAT_SUB)
                            cons_2 -= cons_1;

                        ConstantInt *new_result = ConstantInt::get(second->getType(), cons_2); // new result

                        foldInfo temp;
                        temp.foldable = willFold;
                        temp.result = new_result;
                        folds[InstructionIDs[I]] = temp;
                    }
                }
            }
        }

        for (auto &B : F)
        {
            for (auto &I : B)
            {
                errs() << "INSTRUCTION: ";
                I.print(errs());
                errs() << "\n";
                errs() << "***************** "
                       << "GEN"
                       << "\n{"
                       << "\n";
                for (auto gen : GEN[&I])
                {
                    errs() << " " << *(Instructions[gen]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "KILL"
                       << "\n{"
                       << "\n";
                for (auto kill : KILL[&I])
                {
                    errs() << " " << *(Instructions[kill]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "IN"
                       << "\n{"
                       << "\n";
                for (auto in : IN[&I])
                {
                    errs() << " " << *(Instructions[in]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "***************** "
                       << "OUT"
                       << "\n{"
                       << "\n";
                for (auto out : OUT[&I])
                {
                    errs() << " " << *(Instructions[out]) << "\n";
                }
                errs() << "}"
                       << "\n**************************************\n";

                errs() << "\n\n\n";
            }
        }

        /* CONSTANT PROPAGATION ----
         * Look at all invocations of CAT_GET. Extract the argument (CAT var) inside that CAT_GET function (GET_ARG_ONE).
         * Look at the IN set of that CAT_GET function, if the CAT var is present in any of the instructions in the IN set
         *  --- specifically in the first arg of CAT_SET/ADD/SUB or if it's the actual instruction (CAT_NEW). 
         * 
         * For each of those instructions: if the inst is a CAT_SET/NEW, then extract the constant int value from that inst. 
         * If the inst is a CAT_ADD/SUB --- check the folds hash table to see if that cat_add/sub is foldable. If so, extract
         * the folded constant value from the folds hash table. For each of these values, record the value in uniqueConstsFromIN
         * table.
         * 
         * If there is ONLY one unique key in the uniqueConstsFromIN set, propagate that constant into the CAT_GET function
         * 
         * FOR H5 --- if a var passed to CAT_GET Is a PHINode --- that is addressed to find a constant value (less conservative
         * than the analysis in constant folding). Args table is checked to make sure that no stores, escaped variables are
         * propagated
         * 
         * NOTE: If a cat_ADD/SUB is not foldable, the value of the cat_add/sub inst in the uniqueConstsFromIN table is set 
         * to -1. This is checked when propagating to make sure that a non-foldable constant isn't propagated
         */

        for (map<Value *, set<Value *>>::iterator it = defs.begin(); it != defs.end(); ++it)
        {
            Value *curr = it->first;
            errs() << "CURRENT DEFINITION: ";
            curr->print(errs());
            errs() << "\n";

            // for (auto &U : curr->uses())
            // {
            //     errs() << "USER: \n";
            //     User *user = U.getUser();
            //     user->print(errs());
            //     errs() << "\n";
            // }

            errs() << "\n";
            set<Value *> temp = it->second;
            errs() << "Here are its definitions: \n";
            for (set<Value *>::iterator sit = temp.begin(); sit != temp.end(); ++sit)
            {
                (*sit)->print(errs());
                errs() << "\n";
            }
            errs() << "------\n\n\n";
        }
        errs() << "Passed\n";

        for (auto cat_get_inst : invocations[CAT_GET])
        {
            Value *I = Instructions[cat_get_inst];
            map<Value *, uint32_t> uniqueConstsFromIN; // map to remove duplicates

            if (auto *call = dyn_cast<CallInst>(I))
            {
                errs() << "if of get\n";
                Value *GET_ARG_ONE = cast<Value>(call->getArgOperand(0));

                // if the variable passed into cat_get is a PHI Node ---
                // Need to extract all possible constants that can be chosen
                // A true constant can be propagated only if all the constants
                // of the possible values in the phi node instruction are the same
                bool opI_argument = false;
                if (auto *arg_one_inst = dyn_cast<Instruction>(GET_ARG_ONE))
                {
                    if (isa<PHINode>(arg_one_inst))
                        unrollPHINode(arg_one_inst, uniqueConstsFromIN, CATs, args);
                }

                //check the in set to make sure that there is only one reaching definition
                //for the argument for cat_get
                for (auto in : IN[I])
                {
                    Value *v; // the value that will be stored in the uniqueConstsFromIN table later
                    //cat_new
                    if (InstructionIDs[GET_ARG_ONE] == in) // the instruction is the definition --- therefore CAT_NEW
                    {
                        // **** CHECK THE ARGS TABLE ****
                        if (args.count(Instructions[in]) > 0)
                            continue; // not considering arguments or stores

                        if (auto *inst = dyn_cast<CallInst>(GET_ARG_ONE))
                        {
                            v = inst->getArgOperand(0); // set v to the constant value that can be propagated (first arg of cat_new)
                            uniqueConstsFromIN[v] = 1;  // add entry to the table: v is the key, 1 is the value
                        }
                    }
                    //cat_set, rest
                    else
                    {
                        //need to fix below code repitition
                        if (auto *in_call = dyn_cast<CallInst>(Instructions[in]))
                        {
                            Function *callee = in_call->getCalledFunction();

                            if (CATs.count(callee) > 0)
                            {
                                // code repeated on purpose, memory corruption occurs if control flow simplified
                                // for the following if statements
                                auto id = CATs[callee];
                                if (id == CAT_SET)
                                {
                                    Value *op = in_call->getArgOperand(0); // var passed to CAT_SET

                                    // **** CHECK THE ARGS TABLE ****
                                    if (args.count(op) > 0)
                                        continue; // not considering arguments or stores

                                    // check to see if GET_ARG_ONE (the CAT var) is the var passed to CAT_SET
                                    if (InstructionIDs[GET_ARG_ONE] == InstructionIDs[op])
                                    {
                                        v = in_call->getArgOperand(1); // grab the constant value: (i.e. CAT_SET(___, v) )
                                        uniqueConstsFromIN[v] = 1;     // add entry to the table: v is the key, 1 is the value
                                    }
                                }
                                else if (id == CAT_ADD || id == CAT_SUB)
                                {
                                    // check to see if GET_ARG_ONE (the CAT var) is the var passed to CAT_ADD/SUB

                                    Value *op = in_call->getArgOperand(0);

                                    // This is a hacky fix --- InstructionIDs[op] will return
                                    // 0 if it's not in the map. So if the first instruction
                                    // happens to be compared to op, then that creates an inaccurate
                                    // result --- so check the args table to filter through possible
                                    // *op that won't be in the instructions table --- i.e. something
                                    // in the args table
                                    if (args.count(op) > 0)
                                        continue;

                                    if (InstructionIDs[GET_ARG_ONE] == InstructionIDs[op])
                                    {
                                        Value *in_call_inst = cast<Value>(in_call);
                                        if (folds.count(InstructionIDs[in_call_inst]) > 0)
                                        {
                                            // The following checks to see if the constant folded value exists in the uniqueConstsFromIN
                                            // table, and extracts the value to that key (the constant value). If that key (currVal) is 1,
                                            // then either that key is from a CAT_SET/CAT_NEW (where the value was set to 1 for a key),
                                            // or the key is from a CAT/ADD/SUB instruction that IS foldable.

                                            // If that currVal is not 1, then the foldable constant from the current CAT_add/sub inst is NOT
                                            // recorded.

                                            // If currVal is 1, record the foldable constant as a key, set its value to 1 if it's foldable
                                            // or set its value to -1 if the add/sub instruction is not foldable
                                            v = folds[InstructionIDs[in_call_inst]].result;

                                            uint32_t currVal = 1;
                                            if (uniqueConstsFromIN.count(v) > 0)
                                                currVal = uniqueConstsFromIN[v];

                                            if (currVal == 1)
                                            {
                                                if (folds[InstructionIDs[in_call_inst]].foldable)
                                                    uniqueConstsFromIN[v] = 1;
                                                else
                                                    uniqueConstsFromIN[v] = -1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (uniqueConstsFromIN.size() == 1)
                {
                    map<Value *, uint32_t>::iterator it;
                    it = uniqueConstsFromIN.begin();
                    Value *v = it->first;

                    // make sure that even if there's one key in the table, that key is foldable
                    if (it->second != 1)
                        continue;

                    if (isa<ConstantInt>(v))
                    {
                        ConstantInt *arg = cast<ConstantInt>(v);
                        int64_t c = arg->getSExtValue();
                        ConstantInt *newArg = ConstantInt::get(arg->getType(), c);
                        BasicBlock::iterator ii(call);

                        Instruction *inst = cast<Instruction>(I);
                        ReplaceInstWithValue(inst->getParent()->getInstList(), ii, newArg);
                    }
                }
            }
        }
        errs() << "Passed\n";

        // NO DEAD CODE ELIMINATION
        for (auto cat_new_inst : invocations[CAT_NEW])
        {
            Instruction *I = cast<Instruction>(Instructions[cat_new_inst]);
            if (I->getNumUses() == 0) // check if there's one use --- or should it be 1??
                I->eraseFromParent(); // could check the defs table, but this is a simpler solution
        }
        return false;
    }

    Value *getNumericalValue(Value *inst, map<Value *, uint32_t> InstructionIDs, map<uint32_t, foldInfo> folds, map<Function *, uint32_t> CATs)
    {
        Value *NumericalValue = NULL;

        if (inst == NULL)
            return NumericalValue;

        if (auto *call = dyn_cast<CallInst>(inst))
        {
            Function *callee = call->getCalledFunction();
            if (CATs.count(callee) > 0)
            {
                auto id = CATs[callee];
                switch (id)
                {
                case CAT_NEW:
                    NumericalValue = call->getArgOperand(0);
                    break;
                case CAT_SET:
                    NumericalValue = call->getArgOperand(1);
                    break;
                case CAT_ADD:
                case CAT_SUB:
                {
                    if (folds.find(InstructionIDs[inst]) != folds.end())
                        NumericalValue = folds[InstructionIDs[inst]].result;
                }
                break;
                }
            }
        }

        return NumericalValue;
    }

    void copyPropSetOperand(Value *op,
                            Value *I,
                            uint32_t position,
                            map<Value *, set<Value *>> related_NEW,
                            vector<Value *> Instructions,
                            map<Value *, uint32_t> InstructionIDs,
                            map<Value *, SparseBitVector<>> IN,
                            map<Function *, uint32_t> CATs)
    {
        errs() << "func\n";
        if (op == NULL)
            return;

        errs() << "op\n";
        op->print(errs());
        errs() << "\n";

        Value *key = getTableKey(op, related_NEW);

        if (key == NULL)
            return;

        errs() << "key\n";
        key->print(errs());
        errs() << "\n";

        bool get_reach = false;
        bool key_reach = false;

        for (auto in : IN[I])
        {
            if (auto *in_call = dyn_cast<CallInst>(Instructions[in]))
            {
                Function *callee = in_call->getCalledFunction();

                if (CATs.count(callee) > 0)
                {
                    if (CATs[callee] == CAT_NEW)
                    {
                        if (in == InstructionIDs[op])
                            get_reach = true;
                        if (in == InstructionIDs[key])
                            key_reach = true;
                    }
                }
            }
        }

        if (get_reach && key_reach)
        {
            // Instruction *to = cast<Instruction>(key);
            // Instruction *from = cast<Instruction>(op);

            if (auto *temp = dyn_cast<User>(I))
                temp->setOperand(position, key);

            errs() << "Current get:\n";
            I->print(errs());
            errs() << "\n";
            errs() << "This is its relative:\n";
            key->print(errs());
            errs() << "\n";
        }
        errs() << "End func\n";
        return;
    }

    void unrollPHINode(Value *PHI, map<Value *, uint32_t> &values, map<Function *, uint32_t> CATs, map<Value *, set<Value *>> args)
    {
        if (auto *phi = dyn_cast<PHINode>(PHI))
        {
            for (uint32_t opNO = 0; opNO < phi->getNumOperands(); opNO++)
            {
                Value *opI = cast<Value>(phi->getOperand(opNO));

                if (auto *op_call = dyn_cast<CallInst>(opI))
                {
                    Function *op_callee = op_call->getCalledFunction();
                    if (CATs.count(op_callee) > 0)
                    {
                        if (CATs[op_callee] == CAT_NEW)
                        {
                            if (args.count(opI) > 0)
                            {
                                values.clear();
                                return;
                            }
                            else
                            {
                                Value *v = op_call->getArgOperand(0);
                                values[v] = 1;
                            }
                        }
                    }
                }
                else if (auto *in_phi = dyn_cast<PHINode>(opI))
                    unrollPHINode(in_phi, values, CATs, args);
                else if (args.count(opI) > 0)
                {
                    values.clear();
                    return;
                }
            }
        }
    }

    Value *getTableKey(Value *inst, map<Value *, set<Value *>> table)
    {
        Value *d = NULL;
        for (map<Value *, set<Value *>>::iterator it = table.begin(); it != table.end(); ++it)
        {
            d = it->first;
            set<Value *> temp = it->second;

            if (temp.empty() || temp.size() == 1) // could have just itself
                continue;

            auto sit = temp.find(inst);
            if (sit != temp.end())
                break;

            d = NULL;
        }
        return d;
    }

    // int getConst(Value *v)
    // {
    //     if(auto *c = dyn_cast<ConstantInt>(v))
    //     {

    //     }
    // }

    // We don't modify the program, so we preserve all analyses.
    // The LLVM IR of functions isn't ready at this point
    void
    getAnalysisUsage(AnalysisUsage &AU) const override
    {
        //errs() << "Hello LLVM World at \"getAnalysisUsage\"\n" ;
        AU.setPreservesAll();
    }
}; // namespace
} // namespace
// Next there is code to register your pass to "opt"
char CAT::ID = 0;
static RegisterPass<CAT> X("CAT", "Homework for the CAT class");

// Next there is code to register your pass to "clang"
static CAT *_PassMaker = NULL;
static RegisterStandardPasses _RegPass1(PassManagerBuilder::EP_OptimizerLast,
                                        [](const PassManagerBuilder &, legacy::PassManagerBase &PM) {
        if(!_PassMaker){ PM.add(_PassMaker = new CAT());} }); // ** for -Ox
static RegisterStandardPasses _RegPass2(PassManagerBuilder::EP_EnabledOnOptLevel0,
                                        [](const PassManagerBuilder &, legacy::PassManagerBase &PM) {
        if(!_PassMaker){ PM.add(_PassMaker = new CAT()); } }); // ** for -O0

